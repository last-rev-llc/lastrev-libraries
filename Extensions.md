# Last Rev GraqphQL Extensions

The LastRev Framework allows you to create a GraphQL schema that is bsaed on the content models in Contentful. Most people will be able to use the generated schema without too many modifications. But if you want to add custom fields or resolver behavior, you can do so by Through extensions.

## Out of the box functionality

The schema that is generated by the LastRev Framework is based on the content models in Contentful and applies a few changes to make them compatible with Graphql Schema types and best practices. The following changes are applied:

1. The capitalized id of the content model is used as the name of the GraphQL type. For example, `pageGeneral` becomes `PageGeneral`.
2. All fields are mapped to GraphQL primitive types, or to custom types included in our schema:

| Contentful field type           | GraphQL type       | Notes                                                       |
| ------------------------------- | ------------------ | ----------------------------------------------------------- |
| `Symbol`                        | `String`           |                                                             |
| `Text`                          | `String`           |                                                             |
| `RichText`                      | `RichText`         | A custom GraphQl Type represnting RichText content          |
| `Integer`                       | `Int`              |                                                             |
| `Number`                        | `Float`            |                                                             |
| `Boolean`                       | `Boolean`          |                                                             |
| `Date`                          | `Date`             | A custom GraphQL type representing a datetime               |
| `Location`                      | `Location`         | A custom GraphQL type representing a location               |
| `Object`                        | `JSON`             | A custom GraphQL Scalar representing a JSON blob            |
| `Link` <br/>(linkType: `Asset`) | `Media`            | A custom GraphQL type representing an Asset                 |
| `Link` <br/>(linkType: `Entry`) | `Content`          | A custom GraphQL interface implemented by all content types |
| `Array`                         | Array of the above |                                                             |

3. field names are the same as the ID of the field in the content model.
4. fields are referenced directly on the parent item, for example `pageGeneral.fields.title` becomes `pageGeneral.title`,
5. `sys` properties are excluded, but if needed, additional mappers or resolvers can be used to expose these (see below).
6. The type name is exposed as `__typename` on the resolved object. This is derived from the content model ID as described in point 1 above.
7. Additional fields that are part of the `Content` interface are exposed as properties on the resolved object:

| Field            | Description                                                                                                                                                                                                                                                                    |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `id`             | The ID of the content model                                                                                                                                                                                                                                                    |
| `theme`          | An type containing a single `variant` string field (needs to be implemented in a mapper)                                                                                                                                                                                       |
| `animation`      | A `JSON` object containing animation data (needs to be implemented in a mapper)                                                                                                                                                                                                |
| `sidekickLookup` | A `JSON` object containing mappings from graphQL fields to contentful fields they were derived from. For use implementing the [LastRev Contentful Sidekick](https://chrome.google.com/webstore/detail/contentful-sidekick/cmheemjjmooepppggclooeejginffobo?hl=en-US) HTML tags |

## Description of Extensions

### TypeDefs

A TypeDef extension can be used to create new types or extend existing types. The [graphql-tag](https://github.com/apollographql/graphql-tag) library can be used to declare type definitions.

For example, creating a new type:

```typescript
import gql from 'graphql-tag';

export const typeDefs = gql`
  type SomeNewType {
    name: String
    description: String
    reference: Content
  }
`;
```

Or extending an existing type:

```typescript
import gql from 'graphql-tag';

// adds a new field, settingsGlobal, a reference to a SettingsGlobal type to the PageGeneral type.
export const typeDefs = gql`
  extend type PageGeneral {
    settingsGlobal: SettingsGlobal
  }
`;
```

**Note**: Changing the return type of an existng field is not possible. For reference fields this should not be a problem, since all reference fields are typed as `Content`. If a change is needed, a workaround would be to create a new field and use a mapper to resolve it.

### Mappers

Mappers are a construct that we use on top of the standard [Apollo GraphQL Resolvers](https://www.apollographql.com/docs/apollo-server/data/resolvers/) to allow for resolution and mapping of fields. In most cases, mapping fields and resolving values for fields coming from Contentful can and should be done through mappers. If more complex behavior or other data sources are needed, a custome resolver can be used (see Resolvers below).

**Display Types**

Mappers introduce the concept of a display type. This is a useful way to shoehorn one type into another. For Example, may times we want to display something in a `Card` type, but do not want to go through the trouble of creating a Card content item that has a pointer to a different item in it. Instead, we can simply use mappers to map the existing item into a `Card` item.

**Field Mappers**

Fields can be mapped by either using a simple string, which tells the mapper to resolve the field using the value of the field name referenced in the string, or using the standard [resolver function signature](https://www.apollographql.com/docs/apollo-server/data/resolvers/#resolver-arguments).

**Apollo Context**

The third argument of the resolver function is the `context` object. This is a special object that is passed to the resolver function. It contains information about the request, and some useful functions to help with the resolution of the field. See the defined [ApolloContext Type](packages/types/index.d.ts) for details.

**Structure**

Mappers are defined in a 3 level object structure, with the type at the top level, the display type at the second level, and the field at the third level.

**Example**

```typescript
export const mappers = {
  PageGeneral: {
    PageGeneral: {
      // resolve this virtual field in pageGeneral
      settingsGlobal: async (item: any, _: never, ctx: ApolloContext) => {
        const settingsGlobal = await ctx.loaders.entryLoader.load({ id: process.env.CONTENTFUL_SETTINGS_ID, preview: !!ctx.preview});

        return settingsGlobal
      }
    }
    Card: {
      // these fields are mapped using strings
      title: 'pageTitle' // resolves from pageGeneral.fields.pageTitle
      content: 'body' // resolves from pageGeneral.fields.body
    }
  }
}
```

### Resolvers

[Resolvers](https://www.apollographql.com/docs/apollo-server/data/resolvers/) are useful when you need to create new queries, or whole new types that are not tied to content in Contentful.

Similar to mappers, you would use a resolver function to define the behavior of the field. The same ApolloContext object is passed in.

```typescript
export const resolvers = {
  Query: {
    tweets: async (_: never, args: { userId }, ctx: ApolloContext) => {
      const tweets = await axios.get(`https://api.twitter.com/2/users/${userId}/tweets`);

      return tweets;
    }
  },
  Tweet: (tweet: any, _: never, ctx: ApolloContext) => {
    return {
      content: tweet.text,
      // get CMS data for the author, if it exists
      author: await ctx.loaders.entryLoader.load({ id: tweet.authorId, preview: !!ctx.preview })
    };
  }
};
```

### PathConfigs

Lastly, PathsConfigs is how you can define how your webiste paths are generated. The PathsConfigs object is a map of the content type ID to either a pathsConfig Generator function, or a string that will be the root prepended to the slug field of the item.

**Path Generator Functions**
The path generator function gets passed the content item, loaders, default locale, locales, whether it is preview, and the site string (for setups with multiple sites).

It should return an object, keyed by the path, whose value contains the full path, whehter it is the primary path of this content item (can be used for canonical URLs), the contentID of the item, and an array of excluded locales.

The path generator function can generate complex paths with child/parent logic using the loaders to load the parent or child items.

```typescript
const pageGeneral: ContentfulPathsGenerator = async (
  pageItem,
  loaders,
  defaultLocale,
  locales,
  preview = false,
  site
) => {
  if (await validateSite({ item: pageItem, loaders, preview, site, defaultLocale, locales })) {
    const slug = getDefaultFieldValue(pageItem, 'slug', defaultLocale);
    if (!slug) return {};

    const fullPath = slug === 'home' ? '/' : `/${slug}`;

    let parentRef = getDefaultFieldValue(pageItem, 'parent', defaultLocale);

    // Go up the parent tree, prepending parent slug, until no parent is found
    while (parentRef) {
      const parentItem = await loaders.entryLoader.load({ id: parentRef.sys.id, preview });
      if (!parentItem) break;
      const parentSlug = getDefaultFieldValue(parentItem, 'slug', defaultLocale);

      fullPath = `/${parentSlug}${fullPath}`;

      parentRef = getDefaultFieldValue(parentItem, 'parent', defaultLocale);
    }

    return {
      [fullPath]: {
        fullPath,
        isPrimary: true,
        contentId: pageItem.sys.id,
        excludedLocales: []
      }
    };
  }
  return {};
};

export const pathsConfigs = {
  pageGeneral,
  pageBlog: '/blogs' // this will autmoatically create the path config for each blog with this path: /blogs/{blog.fields.slug['en-US']}
};
```

## Helper functions

The `@last-rev/graphql-contentful-core` package includes a few helper functions that can be used to help with the creation of mappers and resolvers.

### getDefaultFieldValue

The `getDefaultFieldValue` function allows one to get the value of the field for the default locale.

Arguments:

- item (`Entry<any>`) - the content item
- fieldname (`string`) - the name of the field to get the value of
- defaultLocale (`string`) or ctx (`ApolloContext`) - you can either pass the default locale directly, or pass in the context object)

```typescript
const slug = getDefaultFieldValue(item, 'slug', ctx.defaultLocale);

const internalTitle = getDefaultFieldValue(item, 'internalTitle', ctx);
```

### getLocalizedField

The `getLocalizedField` function allows one to get the value of the field for the current locale, or, if it does not exist, return the default locale field value.

Arguments:

- item (`Entry<any>`) or field (`Entry<any>['fields']`) - the content item or the fields object of the content item
- fieldname (`string`) - the name of the field to get the value of
- ctx (`ApolloContext`) - the ApolloContext object)

```typescript
const slug = getlocalizedField(item, 'slug', ctx);
```

### createRichText

This function is used to convert a plain text string into a rich text object. This is useful if your component expects a rich text field, but you may be rendering a different content type that only has a string field into that component

Arguments:

- text (`string`) - the text to convert

```typescript
const richText = createRichText(text);
```
